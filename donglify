#!/bin/python3

import os
import sys
import subprocess
import stat
import pathlib
import configparser
import signal

from termcolor import colored

DONGLE_EFI_UUID = "efi_uuid"
DONGLE_LOCKED_BOOT_UUID = "locked_boot_uuid"
DONGLE_UNLOCKED_BOOT_UUID = "unlocked_boot_uuid"

DONGLE_INSTALL_KERNEL_NAME = "kernel_name"
DONGLE_INSTALL_CRYPTOKEYFILE = "cryptokeyfile"
DONGLE_INSTALL_HOOKS_ADDED = "hooks_added"
DONGLE_INSTALL_UCODE = "ucode"

state_ask_cmd = False

dongle_config = None

dongle_installs_configs = {}

def good(msg):
    print(colored(msg, "green"))

def disk_exists(path):
     try:
             return stat.S_ISBLK(os.stat(path).st_mode)
     except:
             return False

def execute(cmd, desc="", ask=False, needed=True, dry_run=False):
    global state_ask_cmd
    if not state_ask_cmd:
        ask = False

    assert (ask and desc != "") or not ask
    if ask:
        print()
        print("You are about to execute the following command as {}:".format(colored("SUDO", "yellow", attrs=["blink"])))
        print()
        print(colored(cmd, "red", attrs=["reverse", "blink", "bold"]))
        print()
        print("Is command needed? " + ("Yes" if needed else "No"))
        print("Is command ran as dry-run? " + ("Yes" if dry_run else "No"))
        print("Command Description: " + desc)
        print()
        yesno = input("Do you accept after review? [YES/no] ")
        if yesno != "YES":
            print("Not executing by command of user")
            if needed:
                print("This was a needed command, refusing to continue.\nFarewell.")
                sys.exit(1)
            return
    else:
        print(colored("executing: ", "green", attrs=["bold"]) + colored(cmd, "yellow", attrs=["bold"]) + \
                colored(f' # {desc}', "dark_grey"))

    proc = subprocess.run(cmd, shell=True)
    if proc.returncode != 0 and needed:
        print(f'Return code of {proc.returncode} was not 0, exiting')
        sys.exit(proc.returncode)

def locate_and_load_config(dev_name):
    print("attempting to locate dongle.ini")

    __unlock_disk(dev_name, "dongleboot")
    __mount_mapper("dongleboot", "/boot")

    if not pathlib.Path("/boot/dongle.ini").exists():
        print(colored("/boot/dongle.ini does not exist, choose another device partition or run dongle init", "red"))
        sys.exit(1)

    config = configparser.ConfigParser()
    config.read("/boot/dongle.ini")

    global dongle_config
    dongle_config = config["dongle"]

    global dongle_installs_configs
    for key in config.sections():
        if key == "dongle":
            continue

        dongle_installs_configs[key] = config[key]

    print(colored("Please review that this is the correct dongle config contents and that there are no alterations from"
                  " previous access.", "yellow"))
    print()
    config.write(sys.stdout, space_around_delimiters=True)
    answer = input("Looks good? [YES/no] ")
    if answer != "YES":
        print("dongle.ini has been rejected by user command.")
        sys.exit(1)

    dongle_mount_all()

def dongle_save_config():
    # assumes all mounts are right and just writes config into /boot/dongle.ini
    global dongle_config
    global dongle_installs_configs
    config = configparser.ConfigParser()
    config.read_dict({"dongle": dongle_config})

    for name, install_config in dongle_installs_configs.items():
        config.read_dict({name: install_config})

    with open("/boot/dongle.ini", 'w') as f:
        config.write(f, space_around_delimiters=True)

def __unlock(uuid, cryptname):
    if not disk_exists(f'/dev/mapper/{cryptname}'):
        cmd = f'cryptsetup open /dev/disk/by-uuid/{uuid} {cryptname}'
        execute(cmd, desc=f'Unlock UUID={uuid} partition and name it as {cryptname}', needed=True, ask=True)

def __unlock_disk(disk, cryptname):
    if not disk_exists(f'/dev/mapper/{cryptname}'):
        cmd = f'cryptsetup open {disk} {cryptname}';
        execute(cmd, desc=f'Unlock disk {disk} partition and name it as {cryptname}', needed=True, ask=True)

def __lock(luksname):
    if disk_exists(f'/dev/mapper/{luksname}'):
        cmd = f'cryptsetup close {luksname}'
        execute(cmd, desc=f'Lock the dongle\'s {luksname} parition', needed=True, ask=True)

def __mount(uuid, dest):
    if not os.path.ismount(f'{dest}'):
        cmd = f'mount UUID={uuid} {dest}'
        execute(cmd, desc=f'mount dongle\'s partition UUID={uuid} to {dest}', needed=True, ask=True)

def __mount_mapper(mapper_name, dest):
    if not os.path.ismount(f'{dest}'):
        cmd = f'mount /dev/mapper/{mapper_name} {dest}'
        execute(cmd, desc=f'mount dongle\'s partition mapper name {mapper_name} to {dest}', needed=True, ask=True)

def __umount(mntpnt):
    if os.path.ismount(f'{mntpnt}'):
        cmd = f'umount {mntpnt}'
        execute(cmd, desc=f'un-mount dongle\'s {mntpnt}', needed=True, ask=True)

def __ensure_local_dirs_mountpoint_only():
    if not os.path.ismount("/efi") and not os.path.ismount("/boot"):
        cmd = 'chattr +i /efi'
        execute(cmd, desc=f'make host /efi only a mountpoint', needed=False, ask=True)
        cmd = 'chattr +i /boot'
        execute(cmd, desc=f'make host /efi only a mountpoint', needed=False, ask=True)

def __get_uuid_by_dev(dev_name):
    cmd = f'lsblk -n -oNAME,UUID {dev_name} --raw'
    return subprocess.run(cmd, shell=True, capture_output=True).stdout.decode("utf-8") \
            .strip().split('\n')[0].split(' ')[-1].strip()

def __select_dongle_install():
    global dongle_installs_configs
    names = dongle_installs_configs.keys()

    if len(names) == 0:
        return ""

    print("Select from available dongle install names:\n\t" + \
          colored(' '.join(names), 'green'))
    
    return prompt("select> ", completer=WordCompleter(names, ignore_case=False))

def __pacman_install_pkgs():
    cmd = 'pacman -S grub'
    subprocess.run(cmd, shell=True)

def __kernel_config_current_sys(current_install):
    with open("templates/mkinitcpio.conf", "r") as mkinitcpioconf:
        template = mkinitcpioconf.read()
        template = template.replace("$CRYPTO_KEYFILE", current_install["cryptokeyfile"])
        template = template.replace("$HOOKS_ADDED", current_install["hooks_added"])
        pathlib.Path("/etc/mkinitcpio.conf").write_text(template)
        print("wrote /etc/mkinitcpio.conf")

    KERNEL_NAME = current_install['kernel_name']
    UCODE_NAME = current_install['ucode']
    cmd = f'pacman -S {KERNEL_NAME} {UCODE_NAME} mkinitcpio'
    execute(cmd, desc=f'install the kernel, microcode, and mkinitcpio', needed=True, ask=True)

    cmd = 'rm /boot/*fallback*'
    execute(cmd, desc=f'remove kernel fallback images', needed=True, ask=True)

    # rename the newly installed images
    new_kernel_image_path = f'/boot/vmlinuz-{current_install["name"]}'
    new_initramfs_image_path = f'/boot/initramfs-{current_install["name"]}.img'
    new_ucode_image_path = f'/boot/{UCODE_NAME}-{current_install["name"]}.img'

    cmd = f"mv -f /boot/vmlinuz-{KERNEL_NAME} {new_kernel_image_path}"
    execute(cmd, desc=f'rename linux kernel image', needed=True, ask=True)
    cmd = f"mv -f /boot/initramfs-{KERNEL_NAME}.img {new_initramfs_image_path}"
    execute(cmd, desc=f'rename initramfs image', needed=True, ask=True)
    cmd = f"mv -f /boot/{UCODE_NAME}.img {new_ucode_image_path}"
    execute(cmd, desc=f'rename microcode image', needed=True, ask=True)

    good("kernel & initramfs should be correctly positioned in /boot for detection by 'grub-mkconfig' now")

def __grub_config_current_sys():
    cmd = "grub-mkconfig -o /boot/grub/grub.cfg"
    execute(cmd, desc=f'configuring grub on dongle', needed=True, ask=True)
    print("grub-mkconfig have been run")

def dongle_mount_all():
    __mount(dongle_config["efi_uuid"], "/efi")
    __unlock(dongle_config["locked_boot_uuid"], "dongleboot")
    __mount(dongle_config["unlocked_boot_uuid"], "/boot")
    good("mounted all necessarily points from donglified usb")

def dongle_umount_all():
    __umount("/efi")
    __umount("/boot")
    __lock("dongleboot")
    __lock("donglepersist")

    good("system mounts are now clean, safe to remove dongle")

def dongle_init_partition(dev_name):
    print(colored(f"Acknowledge that the following procedure *will* destroy ALL data on '{dev_name}'\n"
                  "YOU WILL NOT BE ASKED AGAIN", 'red', attrs=["reverse", "blink", "bold"]))
    ack = input("Acknowledge by writing the following in caps: DESTROY MY DONGLE\n")
    if ack != "DESTROY MY DONGLE":
        print("Stopping procedure by user command. No data was lost.")
        print("Farewell.")
        sys.exit(0)

    cmd = f'parted {dev_name} mklabel gpt'
    execute(cmd, desc="set USB partition table as GPT")

    cmd = f'lsblk -n -oNAME,SIZE {dev_name}'
    dongle_size = str(subprocess.run(cmd, shell=True, capture_output=True).stdout.decode('utf-8')) \
            .strip().split('  ')[1].replace("G", "")
    print("dongle has size: " + dongle_size + "GB")

    dongle_isos_size = int(0.5 * float(dongle_size) * 1024)
    dongle_persistent_size = int(0.5 * float(dongle_size) * 1024)

    print("recommended partition scheme: ")
    print("DONGLE_EFI partition: 256 MB")
    print("DONGLE_BOOT partition: 2048 MB")
    print("DONGLE_ISOs partition: " + str(dongle_isos_size) + " MB")
    print("DONGLE_PERSISTENT partition: " + str(dongle_persistent_size) + " MB")

    iso_size = input("What would you like to have for ISO partition size in MB? [empty for same] ")
    persistent_size = input("What would you like to have for persistent partition size in MB? [empty for same] " )

    if iso_size != "":
        dongle_isos_size = int(iso_size)
    if persistent_size != "":
        dongle_persistent_size = int(persistent_size)

    current_offset = 8
    parted = "parted -a optimal"
    cmd = f'{parted} {dev_name} mkpart "DONGLE_EFI" fat16 {str(current_offset)}MB 256MB'
    execute(cmd, desc="create efi partition on dongle", needed=True, ask=False)

    cmd = f'{parted} {dev_name} set 1 esp on'
    execute(cmd, desc="mark /efi as esp", needed=True, ask=False)

    current_offset += 256 + 8
    cmd = f'{parted} {dev_name} mkpart "DONGLE_BOOT" {str(current_offset)}MB {str(2048 + current_offset)}MB'
    execute(cmd, desc="create boot partition on dongle", needed=True, ask=False)

    cmd = f'{parted} {dev_name} set 2 boot on'
    execute(cmd, desc="mark /boot as boot", needed=True, ask=False)

    current_offset += 2048 + 8
    if iso_size != 0:
        cmd = f'{parted} {dev_name} mkpart "DONGLE_ISOs" {str(current_offset)}MB {str(dongle_isos_size + current_offset)}MB'
        execute(cmd, desc="create ISOs partition on dongle", needed=True, ask=False)
        current_offset += dongle_isos_size + 8

    if persistent_size != 0:
        cmd = f'{parted} {dev_name} mkpart "DONGLE_PERSISTENT" {str(current_offset)}MB 100%'
        execute(cmd, desc="create persistent partition on dongle", needed=True, ask=False)

    cmd = f'mkfs.vfat -n DONGLE_EFI  -F 16 {dev_name}1'
    execute(cmd, desc="format DONGLE_EFI as FAT16", needed=True, ask=False)

    cmd = f'cryptsetup luksFormat --type luks1 {dev_name}2'
    execute(cmd, desc="encrypt dongle's /boot partition, user will be asked for passphrase automatically", needed=True, ask=False)

    __unlock_disk(f'{dev_name}2', "dongleboot")

    cmd = f'mkfs.ext4 /dev/mapper/dongleboot'
    execute(cmd, desc="format dongle's /boot partition as ext4", needed=True, ask=False)

    cmd = f'mkfs.ext4 {dev_name}3'
    execute(cmd, desc="format dongle's ISOs partition as ext4", needed=False, ask=False)

    cmd = f'cryptsetup luksFormat --type luks2 {dev_name}4'
    execute(cmd, desc="encrypt dongle's persistent partition, user will be asked for passphrase automatically", needed=False, ask=False)
     
    __unlock_disk(f'{dev_name}4', "donglepersist")
    cmd = f'mkfs.ext4 /dev/mapper/donglepersist'
    execute(cmd, desc="format dongle's persistent partition", needed=False, ask=False)

    # find uuids and fill into /boot/dongle.ini
    global dongle_config
    dongle_config = {}
    dongle_config["efi_uuid"] = __get_uuid_by_dev(f'{dev_name}1')
    dongle_config["locked_boot_uuid"] = __get_uuid_by_dev(f'{dev_name}2')
    dongle_config["unlocked_boot_uuid"] = __get_uuid_by_dev(f'/dev/mapper/dongleboot')

    # grub-install
    dongle_mount_all()
    cmd = f'grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB --removable'
    execute(cmd, desc="install grub into dongle", needed=True, ask=True)

    dongle_mount_all()
    dongle_save_config()

    subprocess.run("lsblk -f", shell=True)
    good("dongle's partition initialization done")
    print("you are recommended to start adding system installs onto your dongle")
    sys.exit(0)

def dongle_add_current_system():
    print("Fill configs for current system:")
    
    name = input("install name, shown on GRUB: ")
    current_install = {}
    current_install["name"] = name
    current_install[DONGLE_INSTALL_KERNEL_NAME] = input("kernel package name [linux/-hardened/-lts/..]: ")
    current_install[DONGLE_INSTALL_UCODE] = input("microcode package to be installed [intel-ucode/amd-ucode]: ")
    current_install[DONGLE_INSTALL_CRYPTOKEYFILE] = input("encryption key file to be loaded into initramfs [optional]: ")
    current_install[DONGLE_INSTALL_HOOKS_ADDED] = input("hooks to be added to initramfs [optional]: ")

    global dongle_installs_configs
    dongle_installs_configs[name] = current_install
    dongle_save_config()

    print("adding current host system to donglify")
    dongle_umount_all()
    __ensure_local_dirs_mountpoint_only()
    dongle_mount_all()
    __kernel_config_current_sys(current_install)
    __grub_config_current_sys()

def dongle_reinstall_system():
    name = __select_dongle_install()
    if name == "":
        print("no available system configurations to reinstall")
        return

    global dongle_installs_configs
    current_install = dongle_installs_configs[name]
    current_install["name"] = name

    dongle_mount_all()
    __kernel_config_current_sys(current_install)
    __grub_config_current_sys()

def dongle_list_installs():
    global dongle_installs_configs
    if len(dongle_installs_configs) == 0:
        print("no system installs on dongle")
        return

    print("listing registered installs on dongle")

    for name, config in dongle_installs_configs.items():
        print()
        print(f'name: {name}')
        print(f'kernel_name: {config["kernel_name"]}')
        print(f'cryptokeyfile: {config["cryptokeyfile"]}')
        print(f'hooks_added: {config["hooks_added"]}')
        print(f'ucode: {config["ucode"]}')
        print()


def dongle_safe_update():
    name = __select_dongle_install()
    if name == "":
        print("no available installs, try the 'add' command first")

    global current_install
    global dongle_installs_configs
    current_install = dongle_installs_configs[name]
    current_install["name"] = name

    cmd = input("Entire your system's update command: ")
    dongle_mount_all()
    execute(cmd, "Runs user given system update command.", needed=True, ask=True)
    __kernel_config_current_sys()

from prompt_toolkit import prompt
from prompt_toolkit.completion import WordCompleter

donglify_cmds = ['mount', 'unmount', 'add', 'reinstall', 'update', 'status', 'list']

if __name__ == "__main__":
    usage = "Usage: donglify /dev/<name of usb>[index of encrypted dongleboot]\n" + \
            "       donglify init /dev/<name of usb>"

    if len(sys.argv) == 3 and "init" == sys.argv[1] and '/dev/' in sys.argv[2] and len(sys.argv[2]) == len('/dev/xyz'):
        dongle_init_partition(sys.argv[2])
    elif len(sys.argv) != 2 or not '/dev/' in sys.argv[1] or not len(sys.argv[1]) >= len('/dev/xyz0'):
        print(usage)
        sys.exit(1)

    def keyboard_interrupt_handler(x, y):
        print()
        print()
        print("Farewell, Traveller.")
        sys.exit(1)
    signal.signal(signal.SIGINT, keyboard_interrupt_handler)

    print("Welcome to donglify!")

    locate_and_load_config(sys.argv[1])

    try:
        while 1:
            print(colored("available commands: " + ' '.join(donglify_cmds), 'dark_grey'))
            user_input = prompt("donglify> ", completer=WordCompleter(donglify_cmds, ignore_case=True))
            if user_input == 'status':
                subprocess.run("lsblk", shell=True)
            elif user_input == 'list':
                dongle_list_installs()
            elif user_input == 'mount':
                dongle_mount_all()
                subprocess.run("lsblk", shell=True)
            elif user_input == 'unmount':
                dongle_umount_all()
                subprocess.run("lsblk", shell=True)
            elif user_input == 'add':
                dongle_add_current_system()
            elif user_input == 'reinstall':
                dongle_reinstall_system()
            elif user_input == 'update':
                dongle_safe_update()
            else:
                print("Commands: " + " ".join(donglify_cmds))
    except (KeyboardInterrupt, EOFError):
        print()
        print("Farewell, Traveller.")
        sys.exit(0)
        pass


# NOTES WHILE WORKING ON THE PROJECT
# partitions:
#   label: DONGLE_EFI, 256 MiB FAT16
#   label: DONGLE_BOOT, 2048 MiB LUKS
#   label: DONGLE_ISOs, 32000 MiB EXT4
#   label: DONGLE_PERSISTENT, rest MiB LUKS
#
# mounting dongleboot and sdc1
#   grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB --removable
#   configs to change:
#     kernel params:
#       cryptroot to point to /
#       cryptkey is still cryptkey=rootfs:/boot/crypto_keyfile.bin, because key would be in the initramfs
#     mkinitcpio:
#       FILES=(/boot/cryto_keyfile.bin)
#       add hooks: encrypt lvm2 fsck
#   pacman -S mkinitcpio linux-hardened intel-ucode
#   grub-mkconfig -o /boot/grub/grub.cfg
#
# msdos usb does not seem to work with LUKSv2
#
# allowing multiple archlinux installs on the same usb:
#   donglify should be able to handle detached luks headers, so switch to sd-encrypt if not yet done
#   /etc/mkinitcpio.conf: HOOKS=(...systemd...sd-encrypt)
#   /etc/default/grub: remove cryptdevice, cryptkey, maintain root= which is a pure kernel command
#   /etc/crypttab.initramfs: add required internal drive for root partition loading, here is also where to configure
#   detached LUKS header
#   mount all
#   pacman -S mkinitcpio linux-hardened intel-ucode
#
#   install correct kernel image
#   rename kernel & initramfs image/fallback image
#
# having safe updates
#   get update command
#   ensure mount
#   run update command
#   run __kernel_config_current_sys()
